%%
% ----------------------------------------------------------------------------
% "THE BEER-WARE LICENSE" (Revision 42):
% <sebastian.rauh@hs-heilbronn.de/michael.bauer@hs-heilbronn.de> wrote this 
% file. As long as you retain this notice you can do whatever you want with 
% this stuff. If we meet some day, and you think this stuff is worth it, you 
% can buy us a beer in return. 
% Michael Lukas Bauer, Sebastian Felix Rauh
% ----------------------------------------------------------------------------
%%

%%
% ----------------------------------------------------------------------------
% "THE BEER-WARE LICENSE" (Revision 42):
% <sebastian.rauh@hs-heilbronn.de/michael.bauer@hs-heilbronn.de> wrote this 
% file. As long as you retain this notice you can do whatever you want with 
% this stuff. If we meet some day, and you think this stuff is worth it, you 
% can buy us a beer in return. 
% Michael Lukas Bauer, Sebastian Felix Rauh
% ----------------------------------------------------------------------------
%%

\section{Abstract}
Im fortschreitenden Alter fällt es Menschen schwer, regelmäßig Medikamente zum richtigen Zeitpunkt einzunehmen. Oft wird dies durch eine große Anzahl verschiedener Medikamente noch erschwert, die über den Tag eingenommen werden müssen. 

In Zusammenarbeit mit dem \gls{pita} an der HS-Heilbronn wird eine Smartwatch-Anwendung für die Apple Watch entwickelt. Diese basiert stark auf dezenten Benachrichtigungen am Handgelenk. Auch eine native Anwendung, die der Nutzer aktiv bedienen kann, wird erstellt.

Die Anwendung ist aufgrund fehlender Prototypen-Wekzeuge für die Apple Watch nativ in Swift realisiert. Hierbei wird auf Swift als relativ neue Programmiersprache eingegangen.

Die Evaluierung wird an stationären Patienten im Alter von 70-85 vorgenommen. Die Aussage der Befragung ergibt, dass sich eine Uhr als Medium sehr gut eignet, da sie etwas Vertrautes ausstrahlt. Die touchscreen-basierte Steuerung fällt aufgrund reduzierter sensomotorischer Fähigkeiten der Probanden negativ auf. Während die Benachrichtigung mit einhergehender Vibration sehr gut aufgenommen wird, ist die Interaktion mit der Uhr schwerfällig. Die Patienten haben Probleme eine native Anwendung zu starten. In Zukunft könnten diese Probleme mit Hilfe von Accessibility Funktionen der Plattform gelöst werden. Weiter bietet die Uhr interessante Anwendungsmöglichkeiten Menschen im Alltag zu unterstützen.

\section{Einleitende Worte}
Während das Forschungsfeld der \glqq Medication Adherence\grqq - das Einhalten des Medikamentenplans - schon jahrzehntelang erforscht wurde, ist diese Arbeit Teil eines noch sehr jungen Forschungsgebietes. Smartwatches existieren noch nicht lange im Consumer Bereich. Im folgenden ist eine Zusammenfassung der relevanten Forschungen zu finden. Apple`s Programmiersprache Swift sowie die Technologie der Wearables wird beschrieben.
\section{Arbeiten im Forschungsumfeld}
Leider gibt es kaum Arbeiten, welche sich mit dem Thema Smartwatch und \glqq Medication Adherence\grqq   beschäftigen. Dies ist auf das noch junge Forschungsfeld zurückzuführen. Sailer`s Arbeit \cite{Fabian-Sailer:2015aa} bietet einen Einstieg für diese Arbeit. Hier wurde auch die Thematik für das \gls{pita} abgeleitet, dessen Erkenntnisse hier fortgeführt werden. 

Weiter gibt es sehr spannende Forschungen im Bereich der Smartwatchanwendung, die in fortschreitender Entwicklung auch im Bereich \glqq Medication Adherence\grqq vorstellbar sind. Mit Ambient Assisted Living, also der technischen Unterstützung älterer oder eingeschränkter Personen im Haushalt, beschäftigt sich die Arbeit \glqq Non-obstructive Room-level Locating System in Home Environments Using Activity Fingerprints from Smartwatch\grqq\cite{Lee:2015:NRL:2750858.2804272}. Die von dieser Arbeit abgeleitete Lösung kann auch für rechtzeitige Medikamenteneinnahme genutzt werden. So könnte ein Medikationsalarm nur ausgelöst werden, wenn der Patient sich auch im richtigen Zimmer befindet. Durch den kürzeren Weg zum Medikament sinkt die Gefahr, auf der Suche nach dem Medikament, die Einnahme wieder zu vergessen. Die Arbeit von Laput gliedert sich ebenfalls in diesen Bereich ein und hat auch einen Kontextgewinn zur Folge \cite{Laput:2015:ETR:2807442.2807481}. Berührt der Träger des  Smartwatch Prototyps einen Gegenstand, so erkennt die Uhr das elektromagnetische Feld des Gegenstandes. Durch maschinelles Lernen werden nun die Gegenstände mit ihrem elektromagnetischem Feld verknüpft. Nun kann die Uhr erkennen, welchen Gegenstand der Träger berührt. Dieser Kontextgewinn, welche Gegenstände der Träger der Uhr berührt, könnte Fehler bei Medikamenteneinnahmen verhindern, indem die Uhr die Medikamente erkennt, die der Patient berührt.
Die Studie \glqq Smartwatch in vivo\grqq \cite{Pizza:2016} untersucht das Nutzungsverhalten von Smartwatch Nutzern. Hierzu trägt der Nutzer eine Schulterkamera, die die Interaktion mit der Uhr über drei Tage filmt. So zeigt die Studie auf, dass neben der Uhrzeit (mit ca. 50\% Nutzungsdauer) die Notification mit 20\% an Nutzungsdauer die häufigste Interaktion ist. Anwendungen werden so gut wie nie genutzt. Auch die durchschnittliche Interaktionszeit von ca. 7s ist ein wichtiges Ergebnis.

Orientiert man sich an Arbeiten, deren Ziel die smartphonegestützte Medication Adherence war, findet man unter anderem die aktuelle nationale Umfrage \cite{Krebs-P:2015aa} aus den USA, bei der 1604 Smartphone Nutzer zu ihrer Nutzung von Gesundheitsanwendungen befragt wurden. Fast 50\% der Befragten gaben an, eine oder mehrere Gesundheitsanwendungen auf ihrem Smartphone installiert zu haben. Eine wichtige Aussage der Umfrage war, dass ein Großteil der Nutzer nicht bereit ist für Gesundheitsanwendungen zu bezahlen.

\section{Apple`s Programmiersprache Swift}
Swift wurde im Juni 2014 von Apple vorgestellt und genießt seitdem steigendes Interesse. Im Juni 2015 wurde Version 2.0 veröffentlicht \cite{Apple:2014sp}. Mit Version 2.0 wurde ebenfalls der Plan vorgestellt, Swift Open Source zu machen und somit auch anderen Plattformen die Entwicklung mit Swift zu ermöglichen \cite{Apple:2014sp}. Diesen Plan setzte Apple Ende 2015 in die Tat um. Swift ist nun völlig Open Source. Es können Vorschläge für neue Sprachfunktionen gemacht werden. Auch Apple`s Entwicklungsteam diskutiert seine Pläne für die Sprache öffentlich \cite{Apple:2015swiftOpen}.

\subsection{Objective-C und Swift}
In den frühen 80er Jahren entwickelte Brad Cox die Sprache Objective-C\cite{Dalrymple:2009aa}. Weiter führt Dalrymple aus, dass die Sprache  die Vorteile einer schnellen C-Sprache mit den Vorteilen der objektorientierten Sprache SmallTalk verbinden sollte. Die Firma NextSTEP nutzte Objectiv-C und als NEXTStep von Apple aufgekauft wurde, integrierte Apple Objectiv-C und ermöglichte Mac-Entwicklern die Nutzung.

 Als Apple nun 2008 seine iOS Plattform öffnete und Entwickler eigene Anwendungen für das System schreiben konnten, bekam Objective-C neue Aufmerksamkeit. Viele Entwickler sahen Objective-C als ein Überbleibsel alter Zeiten und waren der Sprache gegenüber negativ eingestellt. Apple stand nun unter Zugzwang um seine Plattform, mit der große wirtschaftliche Interessen verbunden sind, für Entwickler attraktiv zu halten \cite{Wells:2015fu}. Da jedoch alle highlevel APIs in Objectiv-C vorhanden sind, ist es technisch nicht möglich, auf eine bekannte Sprache wie Java für iOS und Mac Entwicklung umzusteigen. Man entschied sich für eine Neuentwicklung mit Hinblick auf neue Programmierparadigmen und auf sehr gute Kompatibilität zu alten Objectiv-C APIs \cite{Wells:2015fu}.

\subsection{Überblick der Neuerung}
\begin{enumerate}
\item Type Inference
\item Closures - Functions as First Class Types
\item Generics
\item Optional Types
\end{enumerate}

\subsection{Type Inference}
Bei Type Inference erkennt der Compiler, welcher Typ in eine Variable instanziiert wurde. Es ist nicht nötig für die Variable eine Typendefinition anzugeben \cite{Apple:2014sp}. Hierdurch wird der Quellcode leichter lesbar. 
\lstinputlisting[caption=Beispiel zu Type Inference in Swift label=lst:typeInference]{02_stateArt/codeExamples/TypeInference.swift}

\subsection{Closures - Functions as First Class Types}
\label{ch:closures}
Während bei strikt objektorientierten Sprachen nur Objekte und primitive Datentypen existieren, gibt es Sprachen, bei denen Funktionen als Typen existieren. Diese Funktionen können auch als Referenz in eine Variable gespeichert werden. Folgende Code Beispiele sollen dies veranschaulichen. Wir nutzen hierfür einen asynchronen Netzwerk-Request\cite{Apple:2014sp}.
\lstinputlisting[caption=Java Beispiel zu First Class Objects, label=lst:firstFuncJava]{02_stateArt/codeExamples/NetworkRequestWithoutFunctions.java}
 In Beispiel \ref{lst:firstFuncJava} wird Java als Repräsentant für eine strikt objektorientierte Sprache verwendet. Hier wird ein Interface definiert, welches der Nutzer des Netzwerk-Requests implementieren muss, um den Request zu empfangen. Beim Aufrufen des Requests muss nun der Aufrufer als Referenz übergeben werden, damit bei Abschließen des Requests der Aufrufer benachrichtigt werden kann (handleNetworkResponse). 
\lstinputlisting[caption=Swift Beispiel zu First Class Objects, label=lst:firstFuncSwift]{02_stateArt/codeExamples/NetworkRequestWithFunctions.swift}
Im Codebeispiel \ref{lst:firstFuncSwift} benötigt es kein Interface für den Nutzer des Netzwerk-Requests. Es ist nun in Swift möglich, eine Funktion zu definieren und diese gleichzeitig in einer lokalen Variablen zu speichern. Nun kann diese Funktion als Referenz zum Netzwerk-Request übergeben werden. Die Funktion wird aufgerufen, wenn der Netzwerk-Request beendet ist. 

\subsection{Generics}
Generics sind schon längere Zeit Teil moderner Programmiersprachen. Sie unterstützen den Entwickler, um Fehler zur Compilezeit zu entdecken. Ein sehr gutes Beispiel hierfür sind Collections (Arrays, Listen, Set, etc). Ein Collection Typ wie Array muss nicht für jeden Typ, den er hält, neu implementiert werden.
\lstinputlisting[caption=Swift Beispiel zu Generic Array Collection, label=lst:generics]{02_stateArt/codeExamples/Generics.swift}
Im Codebeispiel \ref{lst:generics} werden die Vorteile von Generics aufgezeigt. Der erste Versuch einen Array zu implementieren (CustomMedicationArray) zeigt, dass dieser Array eine sehr gute Typen Deklarierung enthält. Der Compiler kann den Entwickler also maximal unterstützen, jedoch ist diese Implementierung minimal wiederverwendbar. Der zweite Ansatz (CustomArray) gibt als Typ-Einschränkung den globalen Supertyp an. Dies führt zu einer maximalen Wiederverwendbarkeit, da jede Klasse von diesem globalen Supertyp erbt (funktioniert nur theoretisch, da in Swift kein Zwang besteht, von einem globalen Supertyp zu erben).
Die letzte Implementierung (GenericArray) nutzt nun Generics. So wird bei der Definition der Klasse ein generischer Typ \glqq T\grqq  eingeführt. Dieser Typ ist eine Art Platzhalter für einen konkreten Typ, der später vom Array gehalten wird. So muss bei der Initialisierung der generischen Klasse die Typ-Information für T übergeben werden (siehe letze Zeile in \ref{lst:generics}).

Das oben beschriebene Beispiel dient nur zur Verdeutlichung des Konzeptes. Swift bietet eine Reihe an Collection Types, darunter auch eine generische Array Implementierung. 

\subsection{Protocol Extension}
Protocol Extension helfen dem Entwickler Abstraktionen, die über ein Interface (in Swift Protocol) definiert werden, zu implementieren und dadurch Duplizierungen zu minimieren. So kann es sein, dass eine Methode eines Interfaces in jeder Klasse, die das Interface implementiert, gleich umgesetzt wird. Dies führt zu einer Code-Duplizierung. 
\lstinputlisting[caption=Swift Beispiel zu Generic Array Collection, label=lst:ProtocolExtensions]{02_stateArt/codeExamples/ProtocolExtensions.swift}
Im Codebeispiel \ref{lst:ProtocolExtensions} wird ein List Interface definiert. Die Extension zu diesem Interface ermöglicht die Implementierung von \glqq last\grqq  und \glqq first\grqq. Diese Implementierung teilen sich nun alle Klassen, die List implementieren.

\subsection{Optional Types}
\label{ch:optionals}
Optional Types eröffnen neue Möglichkeiten beim Modellieren von Datenmodellen und Erstellen von APIs. Es ist so möglich, Argumente in einer Methode als \glqq 0ptional\grqq  zu kennzeichnen und somit dem Nutzer der Methode zu erlauben, eine null-Referenz zu übergeben. Ist kein Optional-Type gekennzeichnet, so verbietet der Compiler eine null-Referenz Übergabe \cite{Apple:2014sp}. Im folgenden Beispiel wird eine Medikation in Java ohne Optional Types und in Swift mit Optional Types modelliert.
\lstinputlisting[caption=Java Beispiel mit fehlenden Optional Types, label=lst:optinalsJava]{02_stateArt/codeExamples/OptionalType.java} 

Im Codebeispiel \ref{lst:optinalsJava} ist zu erkennen, dass zur Compilezeit keine Aussage über den Zustand der Instanz-Variablen getroffen werden kann. Der Entwickler muss also aus dem logischen Kontext erkennen, welche Variablen eine null-Referenz enthalten könnten. Dies kann zu Laufzeitfehlern führen.

\lstinputlisting[caption=Swift Beispiel mit Optional Types, label=lst:optinalsSwift]{02_stateArt/codeExamples/OptionalType.swift}
In \ref{lst:optinalsSwift} sind die Instanzvariablen nun mit Optional Types modelliert. Nun 
kann zur Compilezeit zugesichert werden, welche Variablen eine null-Referenz enthalten können und welche Variablen sicher mit einem Wert belegt sind. Dies führt zu weniger Fehlern während der Laufzeit.

Auch APIs können mit \glqq Optionals\grqq  modelliert werden. So darf ein Parameter nicht null sein, wenn er nicht als Optional definiert wurde. Dies macht eine API strikter und führt ebenfalls zu weniger Laufzeitfehlern, da Fehler schon zur Compilezeit erkannt werden.

\section{Wearables}
Übersetzt man Wearables ins Deutsche, bedeutet es \glqq Tragbares\grqq  oder \glqq Anziehbares\grqq  im Sinne von einem Kleidungsstück tragen. Wenn man nun den Begriff Wearables mit Kleidung assoziiert, liegt man nicht falsch. Anstatt Computer auf dem Schreibtisch oder in der Hosentasche zu haben, trägt man sie am Körper wie Kleidungs- oder Schmuckstücke \cite{Dvorak:2008aa}. Die Grenzen zwischen Kleidung und Computer verschmelzen und es ist manchmal nicht klar, was man schon als Wearable bezeichnen kann oder auch nicht.

Wearables sind meist mit Sensoren ausgestattet, die Daten aus der Körperregion sammeln, an der sie getragen werden \cite{4711366}. Diese Daten zeigen immer nur einen Teilausschnitt. Durch das Tragen von mehreren Geräten am Körper verteilt, können mehr Daten gesammelt werden. So ist es möglich, einen noch genaueren Überblick über den Zustand des Körpers zu erhalten\cite{4711366}.

Erst mit der Miniaturisierung der Computertechnik und Sensoren war es möglich, Computer mit integriertem Akku in Größe einer Streichholzschachtel herzustellen. Während Swatch 1995/1996 eine Uhr vorstellte, die als Skipass funktionierte, stellte Apple 18 Jahre später die Apple Watch vor, die über einen Mikroprozessor, WLAN und eine Vielzahl an Sensoren verfügt (mehr zur Apple Watch in \ref{ch:apple-watch})

Doch nicht nur Uhren zählen zu den Wearables. Google präsentierte mit der Google Glass eine Datenbrille, die über eine Kamera, ein Heads \glqq Prismatic head-mount\glqq  Display, Sprachsteuerung sowie Internetverbindung und weitere Sensoren verfügt \cite{Muensterer2014281}. Auch ein Ring, der mit Hilfe eines Sensors den Puls misst, existiert als Prototyp \cite{4711366}.

Während im Smartphone-Markt noch ein Focus auf Leistung und Funktion der Geräte gelegte wurde, darf man beim Wearables-Markt den Faktor der Ästhetik nicht vergessen. Hier wird ein Bereich betreten, der starke Einflüsse von Mode aufzeigt. Anwender eines Gerätes achten also nicht mehr nur auf die Funktion, sondern auch auf Form, Farbe und Lifestyle den das Produkt verkörpert. Apple bietet unter dem Namen \glqq Watch Edition \grqq eine Apple Watch aus echtem Gold an, deren Preis über 10.000 Euro beträgt und sich an den Luxusmarkt richtet. Auch TAGHeuer, eine Firma, die sich auf luxuriöse und modische Uhren spezialisiert hat, betritt nun auch den Markt der Wearables \cite{TAGHeuer:20015aa}.