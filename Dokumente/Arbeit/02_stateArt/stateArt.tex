%%
% ----------------------------------------------------------------------------
% "THE BEER-WARE LICENSE" (Revision 42):
% <sebastian.rauh@hs-heilbronn.de/michael.bauer@hs-heilbronn.de> wrote this 
% file. As long as you retain this notice you can do whatever you want with 
% this stuff. If we meet some day, and you think this stuff is worth it, you 
% can buy us a beer in return. 
% Michael Lukas Bauer, Sebastian Felix Rauh
% ----------------------------------------------------------------------------
%%

%%
% ----------------------------------------------------------------------------
% "THE BEER-WARE LICENSE" (Revision 42):
% <sebastian.rauh@hs-heilbronn.de/michael.bauer@hs-heilbronn.de> wrote this 
% file. As long as you retain this notice you can do whatever you want with 
% this stuff. If we meet some day, and you think this stuff is worth it, you 
% can buy us a beer in return. 
% Michael Lukas Bauer, Sebastian Felix Rauh
% ----------------------------------------------------------------------------
%%

\section{Einleitende Worte}
Während das Forschungsfeld der "Medication Adherence" - das Einhalten des Medikamentenplans, schon jahrzehntelang erforscht wurde, ist diese Arbeit Teil eines noch sehr jungen Forschungsgebietes. Smartwatches existieren noch nicht lange im Consumer Bereich. Im folgenden ist eine Zusammenfassung der relevanten Forschungen zu finden. Apple`s Programmiersprache Swift, sowie die Technologie der Wearables wird beschrieben.
\section{Arbeiten im Forschungsumfeld}
Leider gibt es kaum Arbeiten, welche sich mit dem Thema Smartwatch und "Medication Adherence" beschäftigen. Dies ist auf das noch junge Forschungsfeld zurückzuführen. Sailer`s Arbeit \cite{Fabian-Sailer:2015aa} bietet einen Einstieg für diese Arbeit. Hier wurde auch die Thematik für das \gls{pita} abgeleitet, deren Erkenntnisse hier fortgeführt werden. 

Weiter gibt es sehr spannende Forschungen im Bereich der Smartwatchanwendung, die in fortschreitender Entwicklung auch im Bereich "Medication Adherence" vorstellbar sind. Mit Ambient Assisted Living, also der technischen Unterstützung älterer oder eingeschränkter Personen im Haushalt, beschäftigt sich die Arbeit "Non-obstructive Room-level Locating System in Home Environments Using Activity Fingerprints from Smartwatch"\cite{Lee:2015:NRL:2750858.2804272}. Die von dieser Arbeite abgeleitete Lösung, kann auch für rechtzeitige Medikamenteneinnahme genutzt werden. So könnte ein Medikationsalarm nur ausgelöst werden, wenn der Patient sich auch im richtigen Zimmer befindet. Durch den kürzeren Weg zum Medikament sinkt die Gefahr, auf der Suche nach dem Medikament, die Einnahme wieder zu vergessen. Die Arbeit von Laput gliedert sich ebenfals in diesen Bereich ein und hat auch einen Kontextgewinn zur Folge hat \cite{Laput:2015:ETR:2807442.2807481}.Berührt Träger des  Smartwatch Prototyp einen Gegenstand, so erkennt die Uhr das  elektromagnetischem Feld des Gegenstandes. Durch maschinelles Lernen werden nun die Gegenstände mit ihren elektromagnetischem Feld verknüft. Nun kann die Uhr erkennen, welchen Gegenstand der Träger berührt. Dieser Kontext Gewinn, welche Gegenstände der Träger der Uhr berührt, könnte Fehler bei Medikamenteneinnahmen verhindern, idem die Uhr die Medikamente erkennt, die der Patient berührt.
Die Studie " Smartwatch in vivo" \cite{Pizza:2016} untersucht das Nutzungsverhalten von Smartwatch Nutzern. Hierzu trägt der Nutzer eine Schulterkamera, die die Interaktion mit der Uhr über 3 Tage filmt. So zeigt die Studie auf, dass neben der Uhrzeit (mit ca. 50\% Nutzungsdauer) die Notification mit 20\% an Nutzungsdauer die häufigste Interaktion ist. Anwendungen werden so gut wie nie genutzt. Auch die durchschnittliche Interaktionszeit von ca. 7s ist ein wichtiges Ergebnis.

Orientiert man sich an Arbeiten, deren Ziel die smartphonegestützte Medication Adherencewar, findet man unter anderem die aktuelle nationale Umfrage \cite{Krebs-P:2015aa} aus den USA, bei der 1604 Smartphone Nutzer zu ihrer Nutzung von Gesundheitsanwendungen befragt wurden. Fast 50\% der Befragten gaben an, eine oder mehrere Gesundheitsanwendungen auf ihrem Smartphone installiert zu haben. Eine wichtige Aussage der Umfrage ist, das der Großteil der Nutzer nicht bereit ist für Gesundheitsanwendungen zu bezahlen.

\section{Apple`s Programmiersprache Swift}
Swift wurde im Juni 2014 von Apple vorgestellt und genießt seitdem steigendes Interesse. Im Juni 2015 wurde Version 2.0 veröffentlicht \cite{Apple:2014sp}. Mit Version 2.0 wurde ebenfalls der Plan vorgestellt, Swift Open Source zu machen und somit auch anderen Plattformen die Entwicklung mit Swift zu ermöglichen \cite{Apple:2014sp}. Diesen Plan setzte Apple Ende 2015 in die Tat um. Swift ist nun völlig Open Source. Es können Vorschläge für neue Sprachfunktionen gemacht werden. Auch Apple`s Entwicklungsteam diskutiert seine Pläne für die Sprache öffentlich \cite{Apple:2015swiftOpen}.

\subsection{Objective-C und Swift}
In den frühen 80er Jahren entwickelte Brad Cox die Sprache Objective-C\cite{Dalrymple:2009aa}. Weiter führt Dalrymple aus, dass die Sprache  die Vorteile einer schnellen C-Sprache mit den Vorteilen der objektorientierten Sprache SmallTalk verbinden sollte. Die Firma NextSTEP nutzte Objectiv-C und als NEXTStep von Apple aufgekauft wurde, integrierte Apple Objectiv-C und ermöglichte Mac-Entwicklern die Nutzung.

 Als Apple nun 2008 seine iOS Plattform öffnete und Entwickler eigene Anwendungen für das System schreiben konnten, bekam Objective-C neue Aufmerksamkeit. Viele Entwickler sahen Objective-C als ein Überbleibsel alter Zeiten und waren der Sprache gegenüber negativ eingestellt. Apple stand nun unter Zugzwang, um seine Plattform, mit der große wirtschaftliche Interessen verbunden sind, für Entwickler attraktiv zu halten \cite{Wells:2015fu}. Da jedoch alle highlevel APIs in Objectiv-C vorhanden sind, ist es technisch nicht möglich, auf eine bekannte Sprache wie Java für iOS und Mac Entwicklung umzusteigen. Man entschied sich für eine Neuentwicklung mit Hinblick auf neue Programmierparadigmen und sehr guter Kompatibilität zu alten Objectiv-C APIs \cite{Wells:2015fu}.

\subsection{Überblick der Neuerung}
\begin{enumerate}
\item Type Inference
\item Closures - Functions as First Class Types
\item Generics
\item Optional Types
\end{enumerate}

\subsection{Type Inference}
Bei Type Inference erkennt der Compiler, welcher Typ in eine Variable instanziert wurde. Es ist nicht nötig für die Variable eine Typendefinition zu definieren \cite{Apple:2014sp}. Hierdurch wird der Quellcode leichter zu lesen. 
\lstinputlisting[caption=Beispiel zu Type Inference in Swift label=lst:typeInference]{02_stateArt/codeExamples/TypeInference.swift}

\subsection{Closures - Functions as First Class Types}
\label{ch:closures}
Während bei strikt objektorientierten Sprachen nur Objekte und primitive Datentypen existieren, gibt es Sprachen, bei denen Funktionen als Typen existieren. Diese Funktionen können auch als Referenz in eine Variable gespeichert werden. Folgende Code Beispiele sollen dies veranschaulichen. Wir nutzen hierfür einen Asynchrones Netzwerk-Request\cite{Apple:2014sp}.
\lstinputlisting[caption=Java Beispiel zu First Class Objects, label=lst:firstFuncJava]{02_stateArt/codeExamples/NetworkRequestWithoutFunctions.java}
 In Beispiel \ref{lst:firstFuncJava} wird Java als Repräsentant für eine strikt objektorientierte Sprache verwendet. Hier wird ein Interface definiert, welches der Nutzer des Netzwerk-Requests implementieren muss, um den Request zu empfangen. Beim Aufrufen des Request, muss nun der Aufrufer als Referenz übergeben werden, damit bei Abschließen des Requests der Aufrufer benachrichtigt werden kann (handleNetworkResponse). 
\lstinputlisting[caption=Swift Beispiel zu First Class Objects, label=lst:firstFuncSwift]{02_stateArt/codeExamples/NetworkRequestWithFunctions.swift}
Im Codebeispiel \ref{lst:firstFuncSwift} benötigt es kein Interface für den Nutzer des Netzwerk-Requests. Es ist nun in Swift möglich, eine Funktion zu definieren und diese gleichzeitig in einer lokalen Variablen zu speichern. Nun kann diese Funktion als Referenz zum Netzwerk-Requests übergeben werden. Die Funktion wird aufgerufen, wenn der Netzwerk-Requests beendet ist. 

\subsection{Generics}
Generics sind schon längere Zeit Teil moderner Programmiersprachen. Sie unterstützen den Entwickler, um Fehler zur Compilezeit zu entdecken. Ein sehr gutes Beispiel hierfür sind Collections (Arrays, Listen, Set, etc). Ein Collection Typ wie Array muss nicht für jeden Typ, den er hält, neu implementiert werden.
\lstinputlisting[caption=Swift Beispiel zu Generic Array Collection, label=lst:generics]{02_stateArt/codeExamples/Generics.swift}
Im Codebeispiel \ref{lst:generics} werden die Vorteile von Generics aufgezeigt. Der erste Versuch, einen Array zu implementieren, (CustomMedicationArray) zeigt, dass dieser Array zwar eine sehr gute Typen Deklarierung enthält. Der Compiler kann den Entwickler also maximal unterstützen, jedoch ist diese Implementierung minimal wiederverwendbar. Der zweite Ansatz (CustomArray) gibt als Typ-Einschränkung den globalen Supertyp an. Dies führt zu einer maximalen Wiederverwendbarkeit, da jede Klasse von diesem globalen Supertyp erbt (funktioniert nur theoretisch, da in Swift kein Zwang besteht, von einem Globalen Supertyp zu erben).
Die letzte Implementierung (GenericArray) nutzt nun Generics. So wird bei der Definition der Klasse ein generischer Typ "T" eingeführt. Dieser Typ ist eine Art Platzhalten für einen konkreten Typ, der später vom Array gehalten wird. So muss bei der Initialisierung der generischen Klasse die Typ-Information für T mitübergeben werden (siehe letze Zeile in \ref{lst:generics}).

Das oben beschriebene Beispiel dient nur zur Verdeutlichung des Konzeptes. Swift bietet eine Reihe an Collection Types, darunter auch eine generische Array Implementierung. 

\subsection{Protocol Extension}
Protocol Extension helfen dem Entwickler Abstraktionen, die über ein Interface (in Swift Protocol) definiert werden, zu implementieren und dadurch Duplizierungen zu minimieren. So kann es sein, dass eine Methode eines Interfaces in jeder Klasse, die das Interface implementiert, gleich umgesetzt ist. Dies führt zu einer Code-Duplizierung. 
\lstinputlisting[caption=Swift Beispiel zu Generic Array Collection, label=lst:ProtocolExtensions]{02_stateArt/codeExamples/ProtocolExtensions.swift}
Im Codebeispiel \ref{lst:ProtocolExtensions} wird ein List Interface definiert. Die Extension zu diesem Interface ermöglicht die Implementierung von "last" und "first". Diese Implementierung teilen sich nun alle Klassen, die List implementieren.

\subsection{Optional Types}
\label{ch:optionals}
Optional Types eröffnen neue Möglichkeiten beim Modellieren von Datenmodellen und erstellen von APIs. Es ist so möglich, Argumente in einer Methode als 0ptional zu kennzeichnen und somit dem Nutzer der Methode zu erlauben eine null-Referenz zu übergeben. Ist kein Optional-Type gekennzeichnet, so verbietet der Compiler ein null-Referenz übergabe \cite{Apple:2014sp}. Im folgenden Beispiel wird eine Medikation in Java ohne Optional Types und in Swift mit Optional Types modelliert.
\lstinputlisting[caption=Java Beispiel mit fehlenden Optional Types, label=lst:optinalsJava]{02_stateArt/codeExamples/OptionalType.java} 

Im Codebeispiel \ref{lst:optinalsJava} ist zu erkennen, dass zur Compilezeit keine Aussage über den Zustand der Instanz-Variablen getroffen werden kann. Der Entwickler muss also aus dem logischen Kontext erkennen, welche Variablen eine null Referenz enthalten könnte. Dies kann zu Laufzeitfehlern führen.

\lstinputlisting[caption=Swift Beispiel mit Optional Types, label=lst:optinalsSwift]{02_stateArt/codeExamples/OptionalType.swift}
In \ref{lst:optinalsSwift} sind die Instanzvariablen nun mit Optional Types modeliert. Nun 
kann zur Compilezeit zugesichert werden, welche Variablen eine null Referenz enthalten können und welche Variablen sicher mit einem Wert belegt sind. Dies führt zu weniger Fehler während der Laufzeit.

Auch APIs können so modelliert werden. So darf ein Parameter nicht null sein, wenn er nicht als Optional definiert wurde. Dies macht eine API strikter und führt ebenfalls zu weniger Laufzeitfehlern, da Fehler schon zur Compilezeit erkannt werden.

\section{Wearables}
Übersetzt man es ins deutsche, bedeutet es "Tragbares" oder "Anziehbares" im Sinne von einem Kleidungsstück tragen. Wenn man nun den Begriff Wearables mit Kleidung assoziiert, liegt man nicht falsch. Anstatt Computer auf dem Schreibtisch oder in der Hosentasche zu haben, trägt man sie am Körper wie Kleidungs -oder Schmuckstücke \cite{Dvorak:2008aa}. Die Grenzen zwischen Kleidung und Computer verschmelzen und es ist manchmal nicht klar, was man schon als Wearable bezeichnen kann oder auch nicht.

Wearables sind meist mit Sensoren ausgestattet, die Daten aus der Körperregion sammeln, an der sie getragen werden \cite{4711366}. Diese Daten zeigen immer nur einen Teilauschnitt. Durch Tragen von mehreren Geräten, am Körper verteilt, können mehr Daten gesammelt werden. So ist es möglich einen noch genaueren Überblick über den Zustand des Körpers zu erhalten\cite{4711366}.

Erst mit der Miniaturisierung der Computertechnik und Sensoren, war es möglich Computer mit integriertem Akku in Größe einer Streichholzschachtel herzustellen. Während Swatch 1995/1996 eine Uhr vorstellte, die als Skipass funktionierte stellte Apple 18 Jahre später die Apple Watch vor, die über eien Mikroprozessor, WLAN und eine Vielzahl an Sensoren verfügt (mehr zur Apple Watch in \ref{ch:apple-watch})

Doch nicht nur Uhren zählen zu den Wearables. Google präsentierte mit der Google Glass eine Datenbrille, die über eine Kamera, ein Heads "Prismatic head-mount" Display, Sprachstuerung, sowie Internetverbindung und weitere Sensoren verfügt \cite{Muensterer2014281}. Auch ein Ring, der mit Hilfe eines Sensoren den Puls misst existiert als Prototyp \cite{4711366}.

Während im Smartphone-Markt noch einen Focus auf Leistung und Funktion der Geräte legte, darf man beim Wearables-Markt des Faktor der Ästhetik nicht vergessen. Hier wird ein Bereich betreten, der starke Einflüsse von Mode aufzeigt. Anwender einer Gerätes achten also nicht mehr nur auch die Funktion, sondern auch auf Form, Farbe und Lifestyle, den das Produkt verkörpert. Apple bietet unter dem Namen "Watch Edition" eine Apple Watch aus echtem Gold an, deren Preis über 10.000 Euro beträgt und sich an den luxusmarkt richtet. Auch TAGHeuer, eine Firma die sich auf luxuriöses modische Uhren spezialisiert hat, betritt nun auch den Markt der Wearables \cite{TAGHeuer:20015aa}.